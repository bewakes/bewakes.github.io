<!doctype html>
<html lang="en">
    <head>
        <meta charset="utf-8">
        <meta http-equiv="x-ua-compatible" content="ie=edge">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <title>bewakes - Minimum Spanning Tree using Kruskal's Algorithm</title>
        <link rel="stylesheet" href="/css/default.css" />
        <link rel="stylesheet" href="/css/syntax.css" />
    </head>
    <body>
        <header>
            <div class="logo">
                <a href="/">bewakes</a>
            </div>
            <nav>
                <a href="/now">now</a>
                <a href="/posts">posts</a>
                <!-- <a href="/book-reviews">book reviews</a> -->
            </nav>
        </header>

        <main role="main">
            
<img src="/images/minimum-spanning-tree-kruskal.png"></img>

<article>
    <section class="header">
        <h1>Minimum Spanning Tree using Kruskal's Algorithm</h1>
        <small>
            May  6, 2017
            
        </small>
        <span><small>&nbsp;&nbsp; tags:</small></span>
        <small><a title="All pages tagged &#39;algorithm&#39;." href="/tags/algorithm/index.html" rel="tag">algorithm</a>, <a title="All pages tagged &#39;graph&#39;." href="/tags/graph/index.html" rel="tag">graph</a>, <a title="All pages tagged &#39;python&#39;." href="/tags/python/index.html" rel="tag">python</a></small>
    </section>
    <section>
        <p>Hey there!! Now we are heading off to finding a minimal spanning tree for an
undirected graph. It is recommended to go through my previous post on <a href="/posts/disjoint-set-data-structure.html">Disjoint
Set Data Structure</a></p>
<p>It is assumed that the reader knows about Graph, a very important data
structure in computer science with lots of applications(social networks,
computer networks, digital circuits, and many more).</p>
<p>An undirected graph has no sense of directions in edges. For example, if we
have an edge connecting two vertices A and B, that edge can be called as
connecting A to B or B to A. The adjacency matrix for the graph is symmetric.
graph</p>
<p>Above is a simple small graph(hand made by me, no wonder why the graph edges
are zig-zagged). The adjacency matrix for the graph is thus,</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="co"># the infinity</span></span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a>INF <span class="op">=</span> <span class="dv">99999999</span></span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a><span class="co"># our adjacency matrix</span></span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a>adjacency <span class="op">=</span> <span class="op">\</span></span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true" tabindex="-1"></a>[[INF,<span class="dv">7</span>,<span class="dv">2</span>,<span class="dv">5</span>],</span>
<span id="cb1-6"><a href="#cb1-6" aria-hidden="true" tabindex="-1"></a>[<span class="dv">7</span>,INF,<span class="dv">4</span>,<span class="dv">1</span>],</span>
<span id="cb1-7"><a href="#cb1-7" aria-hidden="true" tabindex="-1"></a>[<span class="dv">2</span>,<span class="dv">4</span>,INF,<span class="dv">4</span>],</span>
<span id="cb1-8"><a href="#cb1-8" aria-hidden="true" tabindex="-1"></a>[<span class="dv">5</span>,<span class="dv">1</span>,<span class="dv">4</span>,INF]]</span></code></pre></div>
<p>I have chosen adjacency matrix for graph representation here. And as mentioned
earlier, the adjacency matrix is symmetric because it is an undirected graph.
INF means infinity and is the weight of the vertices that are not connected.
Ignore the blue edges for now.</p>
<p>Kruskal’s algorithm goes like this:</p>
<ul>
<li>List out the edges of the graph.</li>
<li>For each edge, make a set containing only the edge. If there are n edges then, there will be n sets(partitions) at this step.</li>
<li>Take an edge with smallest weight value and check if the vertices connected by it are in same set. If not, union them, else continue with the next smallest edge.</li>
<li>Repeat till all vertices are contained in a single set.</li>
</ul>
<h3 id="code">Code</h3>
<p>Lets directly go into the code for the implementation is very very easy.</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb2-1"><a href="#cb2-1" aria-hidden="true" tabindex="-1"></a><span class="co"># number of vertices</span></span>
<span id="cb2-2"><a href="#cb2-2" aria-hidden="true" tabindex="-1"></a>v <span class="op">=</span> <span class="bu">len</span>(adjacency)</span>
<span id="cb2-3"><a href="#cb2-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-4"><a href="#cb2-4" aria-hidden="true" tabindex="-1"></a><span class="co"># now get the edges</span></span>
<span id="cb2-5"><a href="#cb2-5" aria-hidden="true" tabindex="-1"></a><span class="co"># an edge is a tuple (vertex 1, vertex 2, weight)</span></span>
<span id="cb2-6"><a href="#cb2-6" aria-hidden="true" tabindex="-1"></a>edges <span class="op">=</span> [(i, j, adjacency[i][j]) <span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(v) <span class="cf">for</span> j <span class="kw">in</span> <span class="bu">range</span>(i, v) <span class="cf">if</span> adjacency[i][j]<span class="op">!=</span>INF]</span>
<span id="cb2-7"><a href="#cb2-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-8"><a href="#cb2-8" aria-hidden="true" tabindex="-1"></a><span class="co"># sort edges</span></span>
<span id="cb2-9"><a href="#cb2-9" aria-hidden="true" tabindex="-1"></a><span class="co"># because we need to take out smallest edges first.</span></span>
<span id="cb2-10"><a href="#cb2-10" aria-hidden="true" tabindex="-1"></a>edges.sort(key<span class="op">=</span><span class="kw">lambda</span> x: x[<span class="dv">2</span>])</span>
<span id="cb2-11"><a href="#cb2-11" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-12"><a href="#cb2-12" aria-hidden="true" tabindex="-1"></a><span class="co"># CREATE a disjoint set datastructure</span></span>
<span id="cb2-13"><a href="#cb2-13" aria-hidden="true" tabindex="-1"></a><span class="co"># The constructor will automaticall create separate set for each vertex</span></span>
<span id="cb2-14"><a href="#cb2-14" aria-hidden="true" tabindex="-1"></a>disset <span class="op">=</span> DisjointSet(v) <span class="co"># v is number of vertices</span></span>
<span id="cb2-15"><a href="#cb2-15" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-16"><a href="#cb2-16" aria-hidden="true" tabindex="-1"></a>c <span class="op">=</span> <span class="dv">0</span> <span class="co"># counter</span></span>
<span id="cb2-17"><a href="#cb2-17" aria-hidden="true" tabindex="-1"></a>wts <span class="op">=</span> <span class="dv">0</span> <span class="co"># total weight of the final spanning treee</span></span>
<span id="cb2-18"><a href="#cb2-18" aria-hidden="true" tabindex="-1"></a>final_edges <span class="op">=</span> []</span>
<span id="cb2-19"><a href="#cb2-19" aria-hidden="true" tabindex="-1"></a><span class="cf">while</span> c <span class="op">&lt;</span> <span class="bu">len</span>(edges):</span>
<span id="cb2-20"><a href="#cb2-20" aria-hidden="true" tabindex="-1"></a>    edge <span class="op">=</span> edges[c]</span>
<span id="cb2-21"><a href="#cb2-21" aria-hidden="true" tabindex="-1"></a>    i,j, w <span class="op">=</span> edge[<span class="dv">0</span>], edge[<span class="dv">1</span>], edge[<span class="dv">2</span>]</span>
<span id="cb2-22"><a href="#cb2-22" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> disset.find(i) <span class="op">!=</span> disset.find(j):</span>
<span id="cb2-23"><a href="#cb2-23" aria-hidden="true" tabindex="-1"></a>        wts<span class="op">+=</span>w</span>
<span id="cb2-24"><a href="#cb2-24" aria-hidden="true" tabindex="-1"></a>        disset.union(i, j)</span>
<span id="cb2-25"><a href="#cb2-25" aria-hidden="true" tabindex="-1"></a>        final_edges.append(edge)</span>
<span id="cb2-26"><a href="#cb2-26" aria-hidden="true" tabindex="-1"></a>    c<span class="op">+=</span><span class="dv">1</span></span>
<span id="cb2-27"><a href="#cb2-27" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-28"><a href="#cb2-28" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(final_edges)</span></code></pre></div>
<p>Running the above code for the graph shown above, we get the output: <code>[(1, 3, 1), (0, 2, 2), (1, 2, 4)]</code> which are the blue edges in the figure.
That’s all about the Kruskal’s Algorithm. Easy, ain’t it??</p>
    </section>
    <small style="color: #777">
         May  6, 2017

         
    </small>
</article>

        </main>

        <footer>
            Build with love by Bibek Pandey. <br/>
            <br/>
            © 2017 - 2024
        </footer>
    </body>
</html>
