<!doctype html>
<html lang="en">
    <head>
        <meta charset="utf-8">
        <meta http-equiv="x-ua-compatible" content="ie=edge">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <title>bewakes - Disjoint Set Data Structure</title>
        <link rel="stylesheet" href="/css/default.css" />
        <link rel="stylesheet" href="/css/syntax.css" />
    </head>
    <body>
        <header>
            <div class="logo">
                <a href="/">bewakes</a>
            </div>
            <nav>
                <a href="/now">now</a>
                <a href="/posts">posts</a>
                <!-- <a href="/book-reviews">book reviews</a> -->
            </nav>
        </header>

        <main role="main">
            
<img src="/images/disjoint-set-data-structure.png"></img>

<article>
    <section class="header">
        <h1>Disjoint Set Data Structure</h1>
        <small>
            May  5, 2017
            
        </small>
    </section>
    <section>
        <p>As the name suggests, it is a data structure to keep track of the disjoint partitions formed in a set. In case the data structure sounds like ‘WAT??’ or ‘I have not heard about it. Is it useful?’, rest assured, we’ll be seeing the practical application of disjoint set in the next post: <a href="/posts/minimum-spanning-tree-kruskal.html">finding a Minimal Spanning Tree for an undirected graph</a>.</p>
<p>Here, we will be seeing its implementation in Python which is my favourite language(I kind of had love at first sight with python :D ). It is assumed that the reader knows basics of python, and what set, partition, tree, array and list mean.</p>
<p>Okay, now into the technicality of the data structure. It basically provides the following three functions:</p>
<ul>
<li><p><code>make_set(e)</code>: It adds a partition to the set. The partition consists of a single element e. For example, consider a set A={a,b,c,d}
with partitions {a,b} and {c,d}. After the operation, A={a,b,c,d,e} and a new partition {e}.</p></li>
<li><p><code>find(e)</code>: It finds/returns the identification of the partition that e lies in. For example, if the set is A={a,b,c}
, and partitions are B={a} and C={b,c}
, <code>find(b)</code> will return C [We will have some very easy ways to identify a set. Don’t worry about it now.]</p></li>
<li><p><code>union(a, b)</code>: And this wonderful operation will union the sets that contain elements a and b. For example, if the given set is A={a,b,c,d,e}
and the partitions are {a,b}, {c} and {d,e}, union(c, e) will result in the partitions {a,b} and {c,d,e}.</p></li>
</ul>
<h2 id="implementation">Implementation</h2>
<p>We will implement the data structure using tree(implemented as array, relax!! ). A tree represents a set. The root of the tree is the identification of the set. Now, two elements are in same set if they have same root element.</p>
<p>Let’s begin with the basic list to hold the sets. We call it <code>parents_array</code> which holds the parent of an element. Let n be the total number of elements in our set.</p>
<p><code>parents_array = [x for x in range(n)]</code></p>
<p>For example, if <code>parents_array = [2 0 2 2 4]</code>, this means that there are 5 elements and:</p>
<pre><code>2 is parent of 0,
0 is parent of 1,
2 is parent of 2 and is the root,
2 is parent of 3,
4 is parent of 4 and is the root and the only element.</code></pre>
<p>Okay, now let’s implement make_set() function. Since the function is supposed to make a single set of an element, it takes a number as parameter.</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb2-1"><a href="#cb2-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> make_set(i):</span>
<span id="cb2-2"><a href="#cb2-2" aria-hidden="true" tabindex="-1"></a>    parents_array[i] <span class="op">=</span> i</span></code></pre></div>
<p>That’s it. What this does is, sets the parent of an element to itself, which means, that is the set consisting of only that element.</p>
<p>Now, <code>find()</code> function, which finds the parent of an element.</p>
<div class="sourceCode" id="cb3"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb3-1"><a href="#cb3-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> find(e):</span>
<span id="cb3-2"><a href="#cb3-2" aria-hidden="true" tabindex="-1"></a>    <span class="cf">while</span> parents_array[e] <span class="op">!=</span> e:</span>
<span id="cb3-3"><a href="#cb3-3" aria-hidden="true" tabindex="-1"></a>        e <span class="op">=</span> parents_array[e]</span>
<span id="cb3-4"><a href="#cb3-4" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> e</span></code></pre></div>
<p>Here, the tree is traversed until the root element is found (an element is root if its parent is itself).</p>
<p>We’re almost there, only <code>union()</code> remains which unions the sets containing the
input elements. The idea is that, we find the root elements of both elements.
Union means both elements having same root. So, we make one root the parent of
other. Here’s the basic implementation:</p>
<div class="sourceCode" id="cb4"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb4-1"><a href="#cb4-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> union(i, j):</span>
<span id="cb4-2"><a href="#cb4-2" aria-hidden="true" tabindex="-1"></a>    ir <span class="op">=</span> find(i) <span class="co"># root(set id) of element i</span></span>
<span id="cb4-3"><a href="#cb4-3" aria-hidden="true" tabindex="-1"></a>    jr <span class="op">=</span> find(j) <span class="co"># root(set id) of element j</span></span>
<span id="cb4-4"><a href="#cb4-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-5"><a href="#cb4-5" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> ir <span class="op">==</span> jr:</span>
<span id="cb4-6"><a href="#cb4-6" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> <span class="co"># same roots means they are in same set</span></span>
<span id="cb4-7"><a href="#cb4-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-8"><a href="#cb4-8" aria-hidden="true" tabindex="-1"></a>    <span class="co"># set one element as parent of other</span></span>
<span id="cb4-9"><a href="#cb4-9" aria-hidden="true" tabindex="-1"></a>    parents_array[ir] <span class="op">=</span> jr</span>
<span id="cb4-10"><a href="#cb4-10" aria-hidden="true" tabindex="-1"></a>    <span class="co"># or parents_array[jr] = ir, we&#39;ll talk about efficincy later</span></span>
<span id="cb4-11"><a href="#cb4-11" aria-hidden="true" tabindex="-1"></a>    <span class="co"># that&#39;s it</span></span></code></pre></div>
<p>However, we would like to make our data structure and operations on it as optimal as possible, right? First thing we need to be clear is that, we want the find() operation to be as fast as possible. This is obtained when the height of tree is low i.e, reaching the root element from child requires as less steps as possible.</p>
<h2 id="optimization">Optimization</h2>
<p>Now, imagine a situation in which we are doing union. We append one set(tree)
as the child of the other so that both have same root. Appending a shorter tree
to the longer one will result in a tree with height same as the initial height
of the longer tree. If we did otherwise, the height of the shorter tree would
be increased by 1.</p>
<p>So, to keep track of the heights(also called ranks) of the trees, we introduce
another array ranks_array which is initialized as:</p>
<p><code>ranks_array = [0 for x in range(n)] # initial height is zero</code></p>
<p>Now, <code>make_set()</code> becomes,</p>
<div class="sourceCode" id="cb5"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb5-1"><a href="#cb5-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> make_set(i):</span>
<span id="cb5-2"><a href="#cb5-2" aria-hidden="true" tabindex="-1"></a>   parents_array[i] <span class="op">=</span> i</span>
<span id="cb5-3"><a href="#cb5-3" aria-hidden="true" tabindex="-1"></a>   ranks_array[i] <span class="op">=</span> <span class="dv">0</span> <span class="co"># height of single element tree is zero, of course</span></span></code></pre></div>
<p>In <code>union()</code>, we append shorter tree to the longer one and if they have same
<code>rank(height)</code> we can append in any way. But, we need to be careful to increase
the height of the parent tree by 1(You guess why). Changed implementation of
<code>union()</code> will be included in the full code below, which implements Disjoint Set
as class.</p>
<h2 id="full-code">Full code</h2>
<div class="sourceCode" id="cb6"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb6-1"><a href="#cb6-1" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> DisjointSet:</span>
<span id="cb6-2"><a href="#cb6-2" aria-hidden="true" tabindex="-1"></a><span class="co">&quot;&quot;&quot;</span></span>
<span id="cb6-3"><a href="#cb6-3" aria-hidden="true" tabindex="-1"></a><span class="co">Implementation of disjoint sets</span></span>
<span id="cb6-4"><a href="#cb6-4" aria-hidden="true" tabindex="-1"></a><span class="co">&quot;&quot;&quot;</span></span>
<span id="cb6-5"><a href="#cb6-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb6-6"><a href="#cb6-6" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> <span class="fu">__init__</span>(<span class="va">self</span>, n):</span>
<span id="cb6-7"><a href="#cb6-7" aria-hidden="true" tabindex="-1"></a>        <span class="co">&quot;&quot;&quot;</span></span>
<span id="cb6-8"><a href="#cb6-8" aria-hidden="true" tabindex="-1"></a><span class="co">        n is the number of elements</span></span>
<span id="cb6-9"><a href="#cb6-9" aria-hidden="true" tabindex="-1"></a><span class="co">        &quot;&quot;&quot;</span></span>
<span id="cb6-10"><a href="#cb6-10" aria-hidden="true" tabindex="-1"></a>        <span class="co"># create different sets where each is a unique set</span></span>
<span id="cb6-11"><a href="#cb6-11" aria-hidden="true" tabindex="-1"></a>        <span class="va">self</span>.parents_array <span class="op">=</span> [x <span class="cf">for</span> x <span class="kw">in</span> <span class="bu">range</span>(n)]</span>
<span id="cb6-12"><a href="#cb6-12" aria-hidden="true" tabindex="-1"></a>        <span class="va">self</span>.ranks_array <span class="op">=</span> [<span class="dv">0</span> <span class="cf">for</span> x <span class="kw">in</span> <span class="bu">range</span>(n)] <span class="co"># initial rank is zero for all</span></span>
<span id="cb6-13"><a href="#cb6-13" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb6-14"><a href="#cb6-14" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> find(<span class="va">self</span>, p):</span>
<span id="cb6-15"><a href="#cb6-15" aria-hidden="true" tabindex="-1"></a>        <span class="co">&quot;&quot;&quot;</span></span>
<span id="cb6-16"><a href="#cb6-16" aria-hidden="true" tabindex="-1"></a><span class="co">        find the parent of the element (0 indexed)</span></span>
<span id="cb6-17"><a href="#cb6-17" aria-hidden="true" tabindex="-1"></a><span class="co">        &quot;&quot;&quot;</span></span>
<span id="cb6-18"><a href="#cb6-18" aria-hidden="true" tabindex="-1"></a>        <span class="cf">while</span> <span class="va">self</span>.parents_array[p] <span class="op">!=</span> p:</span>
<span id="cb6-19"><a href="#cb6-19" aria-hidden="true" tabindex="-1"></a>            p <span class="op">=</span> <span class="va">self</span>.parents_array[p]</span>
<span id="cb6-20"><a href="#cb6-20" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> p</span>
<span id="cb6-21"><a href="#cb6-21" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb6-22"><a href="#cb6-22" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> make_set(<span class="va">self</span>, i):</span>
<span id="cb6-23"><a href="#cb6-23" aria-hidden="true" tabindex="-1"></a>        <span class="co">&quot;&quot;&quot;</span></span>
<span id="cb6-24"><a href="#cb6-24" aria-hidden="true" tabindex="-1"></a><span class="co">        assign element i to its own set</span></span>
<span id="cb6-25"><a href="#cb6-25" aria-hidden="true" tabindex="-1"></a><span class="co">        &quot;&quot;&quot;</span></span>
<span id="cb6-26"><a href="#cb6-26" aria-hidden="true" tabindex="-1"></a>        <span class="va">self</span>.parents_array[i] <span class="op">=</span> i</span>
<span id="cb6-27"><a href="#cb6-27" aria-hidden="true" tabindex="-1"></a>        <span class="va">self</span>.ranks_array[i] <span class="op">=</span> <span class="dv">0</span></span>
<span id="cb6-28"><a href="#cb6-28" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb6-29"><a href="#cb6-29" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> union(<span class="va">self</span>, i, j):</span>
<span id="cb6-30"><a href="#cb6-30" aria-hidden="true" tabindex="-1"></a>        <span class="co">&quot;&quot;&quot;</span></span>
<span id="cb6-31"><a href="#cb6-31" aria-hidden="true" tabindex="-1"></a><span class="co">        i and j are 0 indexed elements which are to be unioned</span></span>
<span id="cb6-32"><a href="#cb6-32" aria-hidden="true" tabindex="-1"></a><span class="co">        &quot;&quot;&quot;</span></span>
<span id="cb6-33"><a href="#cb6-33" aria-hidden="true" tabindex="-1"></a>        i_root <span class="op">=</span> <span class="va">self</span>.find(i)</span>
<span id="cb6-34"><a href="#cb6-34" aria-hidden="true" tabindex="-1"></a>        j_root <span class="op">=</span> <span class="va">self</span>.find(j)</span>
<span id="cb6-35"><a href="#cb6-35" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb6-36"><a href="#cb6-36" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> i_root <span class="op">==</span> j_root:</span>
<span id="cb6-37"><a href="#cb6-37" aria-hidden="true" tabindex="-1"></a>            <span class="co"># nothing to be done already in same set</span></span>
<span id="cb6-38"><a href="#cb6-38" aria-hidden="true" tabindex="-1"></a>            <span class="cf">return</span></span>
<span id="cb6-39"><a href="#cb6-39" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb6-40"><a href="#cb6-40" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> <span class="va">self</span>.ranks_array[i_root] <span class="op">&lt;</span> <span class="va">self</span>.ranks_array[j_root]:</span>
<span id="cb6-41"><a href="#cb6-41" aria-hidden="true" tabindex="-1"></a>            <span class="va">self</span>.parents_array[i_root] <span class="op">=</span> j_root</span>
<span id="cb6-42"><a href="#cb6-42" aria-hidden="true" tabindex="-1"></a>        <span class="cf">else</span>:</span>
<span id="cb6-43"><a href="#cb6-43" aria-hidden="true" tabindex="-1"></a>            <span class="va">self</span>.parents_array[j_root] <span class="op">=</span> i_root</span>
<span id="cb6-44"><a href="#cb6-44" aria-hidden="true" tabindex="-1"></a>            <span class="cf">if</span> <span class="va">self</span>.ranks_array[i_root] <span class="op">==</span> <span class="va">self</span>.ranks_array[j_root]:</span>
<span id="cb6-45"><a href="#cb6-45" aria-hidden="true" tabindex="-1"></a>                <span class="va">self</span>.ranks_array[i_root]<span class="op">+=</span><span class="dv">1</span></span></code></pre></div>
<p>I hope that was helpful. Feel free to contact me if there are any problems.</p>
    </section>
    <small style="color: #777">
         May  5, 2017

         
    </small>
</article>

        </main>

        <footer>
            Build with love by Bibek Pandey. <br/>
            <br/>
            © 2017 - 2024
        </footer>
    </body>
</html>
