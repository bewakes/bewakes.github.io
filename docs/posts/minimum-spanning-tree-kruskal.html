<!DOCTYPE html>
<html lang="en" class="scroll-smooth">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title></title>

  <link href='https://fonts.googleapis.com/css?family=Open Sans' rel='stylesheet'>

  <script src="https://cdn.tailwindcss.com"></script>
  <script>
    tailwind = {
      config: {
        darkMode: 'class'
      }
    };
  </script>
  <script>
    MathJax = {
        tex: {
            inlineMath: [['$', '$'], ['\\(', '\\)']],
            displayMath: [['$$', '$$'], ['\\[', '\\]']]
        }
    };
    </script>
    <script id="MathJax-script" async 
            src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js">
    </script>

  <link rel="stylesheet" href="/style.css"/>


    <style>
        /* Code block font size override - needs high specificity */
        pre[class*="language-"],
        pre[class*="language-"] code,
        code[class*="language-"] {
            font-size: 1rem !important;
            line-height: 1.4 !important;
            font-family: 'SF Mono', Consolas, 'Liberation Mono', Menlo, Courier, monospace !important;
        }

        /* Additional code styling improvements */
        pre[class*="language-"] {
            margin: 0.5em 0 !important;
            padding-left: 5px !important;
            border-radius: 0.375rem !important; /* rounded-md */
        }

        /* Dark mode toggle styling improvements */
        .dark-toggle {
          position: relative;
          display: inline-flex;
          align-items: center;
          cursor: pointer;
        }

        .dark-toggle input {
          position: absolute;
          opacity: 0;
          width: 0;
          height: 0;
        }

        .toggle-bg {
          width: 44px;
          height: 24px;
          background-color: #d1d5db;
          border-radius: 12px;
          transition: all 0.3s ease;
          position: relative;
        }

        .dark .toggle-bg {
          background-color: #374151;
        }

        .toggle-dot {
          position: absolute;
          top: 2px;
          left: 2px;
          width: 20px;
          height: 20px;
          background-color: white;
          border-radius: 50%;
          transition: transform 0.3s ease;
        }

        .dark .toggle-dot {
          background-color: #f3f4f6;
          transform: translateX(20px);
        }
    </style>

</head>

<body class="font-serif bg-white text-gray-900 dark:bg-gray-900 dark:text-gray-100 transition-colors duration-300">
  <!-- Header -->
  <!-- Header -->
<header class="border-b border-gray-200 dark:border-gray-700">
  <div class="max-w-3xl mx-auto px-4 py-6 flex justify-between items-center">
    <h1 class="text-2xl font-semibold">
        <a class="text-decoration-none" href="/" style="font-family: Open Sans">bewakes</a>
    </h1>
    
    <!-- Navigation Menu -->
    <nav class="hidden md:flex items-center space-x-6" style="font-family: Open Sans">
      <a href="/about.html" class="text-gray-600 dark:text-gray-300 hover:text-gray-900 dark:hover:text-white transition-colors">About</a>
      <a href="/now.html" class="text-gray-600 dark:text-gray-300 hover:text-gray-900 dark:hover:text-white transition-colors">Now</a>
    </nav>

    <div class="flex items-center space-x-4">
      <!-- Mobile Menu Button -->
      <button id="mobileMenuToggle" class="md:hidden p-2 text-gray-600 dark:text-gray-300 hover:text-gray-900 dark:hover:text-white">
        <svg class="w-6 h-6" fill="none" stroke="currentColor" viewBox="0 0 24 24">
          <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M4 6h16M4 12h16M4 18h16"></path>
        </svg>
      </button>
      
      <!-- Toggle Switch -->
      <label class="dark-toggle">
        <input type="checkbox" id="darkModeToggle">
        <div class="toggle-bg">
          <div class="toggle-dot"></div>
        </div>
      </label>
    </div>
  </div>

  <!-- Mobile Menu -->
  <div id="mobileMenu" class="hidden md:hidden border-t border-gray-200 dark:border-gray-700">
    <div class="max-w-3xl mx-auto px-4 py-4 space-y-2">
      <a href="/about.html" class="block py-2 text-gray-600 dark:text-gray-300 hover:text-gray-900 dark:hover:text-white transition-colors">About</a>
      <a href="/now.html" class="block py-2 text-gray-600 dark:text-gray-300 hover:text-gray-900 dark:hover:text-white transition-colors">Now</a>
    </div>
  </div>
</header>


  <main class="max-w-3xl mx-auto px-4 py-10 space-y-10">

    <div class="markdown-content">
    <header>
      <h1 class="title text-4xl text-center">Minimum Spanning Tree using Kruskal&#x27;s Algorithm</h1>
      <p class="post-date text-base text-gray-600 dark:text-gray-400">May 06 2017</p>
    </header>
    <section class="pt-0 mt-2 mb-8">
      <div class="flex flex-wrap gap-3">
            <a href="/tags/algorithm.html" class="text-sm px-3 py-1 rounded-full bg-gray-100 text-gray-700 hover:bg-gray-200 dark:bg-gray-800 dark:text-gray-200 dark:hover:bg-gray-700 transition">
                algorithm
            </a>
            <a href="/tags/graph.html" class="text-sm px-3 py-1 rounded-full bg-gray-100 text-gray-700 hover:bg-gray-200 dark:bg-gray-800 dark:text-gray-200 dark:hover:bg-gray-700 transition">
                graph
            </a>
            <a href="/tags/python.html" class="text-sm px-3 py-1 rounded-full bg-gray-100 text-gray-700 hover:bg-gray-200 dark:bg-gray-800 dark:text-gray-200 dark:hover:bg-gray-700 transition">
                python
            </a>
      </div>
    </section>


    <article class="prose text-xl/8 dark:prose-invert lg:prose-lg max-w-none">
        <p>Hey there!! Now we are heading off to finding a minimal spanning tree for an
undirected graph. It is recommended to go through my previous post on <a href="/posts/disjoint-set-data-structure.html">Disjoint
Set Data Structure</a></p>
<p>It is assumed that the reader knows about Graph, a very important data
structure in computer science with lots of applications(social networks,
computer networks, digital circuits, and many more).</p>
<p>An undirected graph has no sense of directions in edges. For example, if we
have an edge connecting two vertices A and B, that edge can be called as
connecting A to B or B to A. The adjacency matrix for the graph is symmetric.
graph</p>
<p>Above is a simple small graph(hand made by me, no wonder why the graph edges
are zig-zagged). The adjacency matrix for the graph is thus,</p>
<pre><code class="language-python"># the infinity
INF = 99999999
# our adjacency matrix
adjacency = \
[[INF,7,2,5],
[7,INF,4,1],
[2,4,INF,4],
[5,1,4,INF]]
</code></pre>
<p>I have chosen adjacency matrix for graph representation here. And as mentioned
earlier, the adjacency matrix is symmetric because it is an undirected graph.
INF means infinity and is the weight of the vertices that are not connected.
Ignore the blue edges for now.</p>
<p>Kruskal's algorithm goes like this:</p>
<ul>
<li>List out the edges of the graph.</li>
<li>For each edge, make a set containing only the edge. If there are n edges then, there will be n sets(partitions) at this step.</li>
<li>Take an edge with smallest weight value and check if the vertices connected by it are in same set. If not, union them, else continue with the next smallest edge.</li>
<li>Repeat till all vertices are contained in a single set.</li>
</ul>
<h3>Code</h3>
<p>Lets directly go into the code for the implementation is very very easy.</p>
<pre><code class="language-python"># number of vertices
v = len(adjacency)

# now get the edges
# an edge is a tuple (vertex 1, vertex 2, weight)
edges = [(i, j, adjacency[i][j]) for i in range(v) for j in range(i, v) if adjacency[i][j]!=INF]

# sort edges
# because we need to take out smallest edges first.
edges.sort(key=lambda x: x[2])

# CREATE a disjoint set datastructure
# The constructor will automaticall create separate set for each vertex
disset = DisjointSet(v) # v is number of vertices

c = 0 # counter
wts = 0 # total weight of the final spanning treee
final_edges = []
while c &lt; len(edges):
    edge = edges[c]
    i,j, w = edge[0], edge[1], edge[2]
    if disset.find(i) != disset.find(j):
        wts+=w
        disset.union(i, j)
        final_edges.append(edge)
    c+=1

print(final_edges)
</code></pre>
<p>Running the above code for the graph shown above, we get the output: <code>[(1, 3, 1), (0, 2, 2), (1, 2, 4)]</code> which are the blue edges in the figure.
That's all about the Kruskal's Algorithm. Easy, ain't it??</p>

    </article>
</div>


  </main>

  <!-- Footer -->
  <footer class="border-t border-gray-200 dark:border-gray-700 mt-16 py-6 text-center text-sm text-gray-500 dark:text-gray-400">
    &copy; 2025 bewakes.
  </footer>

  <script>
    const toggle = document.getElementById('darkModeToggle');
    const htmlEl = document.documentElement;

    // Function to load Prism theme
    function loadPrismTheme(isDark) {
      // Remove existing theme
      const existingTheme = document.querySelector('link[data-prism-theme]');
      if (existingTheme) {
        existingTheme.remove();
      }

      // Add new theme
      const themeLink = document.createElement('link');
      themeLink.rel = 'stylesheet';
      themeLink.setAttribute('data-prism-theme', 'true');
      
      if (isDark) {
        themeLink.href = 'https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism-tomorrow.min.css';
      } else {
        themeLink.href = 'https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css';
      }
      
      document.head.appendChild(themeLink);
      
      // Re-highlight after theme loads and Prism is ready
      themeLink.onload = function() {
        setTimeout(() => {
          if (typeof Prism !== 'undefined') {
            Prism.highlightAll();
          }
        }, 50);
      };
    }

    // Check for saved theme preference or default to light mode
    const savedTheme = localStorage.getItem('theme');
    const prefersDark = window.matchMedia('(prefers-color-scheme: dark)').matches;
    
    // Initialize theme
    if (savedTheme === 'dark' || (!savedTheme && prefersDark)) {
      htmlEl.classList.add('dark');
      toggle.checked = true;
      loadPrismTheme(true);
    } else {
      htmlEl.classList.remove('dark');
      toggle.checked = false;
      loadPrismTheme(false);
    }

    // Toggle event listener
    toggle.addEventListener('change', () => {
      if (toggle.checked) {
        htmlEl.classList.add('dark');
        localStorage.setItem('theme', 'dark');
        loadPrismTheme(true);
      } else {
        htmlEl.classList.remove('dark');
        localStorage.setItem('theme', 'light');
        loadPrismTheme(false);
      }
    });
  </script>

  <!-- Prism.js JavaScript -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-core.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/plugins/autoloader/prism-autoloader.min.js"></script>

    <script>
        // Configure autoloader path
        Prism.plugins.autoloader.languages_path = 'https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/';

    </script>
  <!-- END Prism.js JavaScript -->
    <script>
        // Mobile menu toggle functionality
        document.getElementById('mobileMenuToggle').addEventListener('click', function() {
          const mobileMenu = document.getElementById('mobileMenu');
          mobileMenu.classList.toggle('hidden');
        });

        // Close mobile menu when clicking outside
        document.addEventListener('click', function(event) {
          const mobileMenu = document.getElementById('mobileMenu');
          const mobileMenuToggle = document.getElementById('mobileMenuToggle');
          
          if (!mobileMenuToggle.contains(event.target) && !mobileMenu.contains(event.target)) {
            mobileMenu.classList.add('hidden');
          }
        });
    </script>

</body>
</html>
