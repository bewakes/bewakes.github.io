<!DOCTYPE html>
<html lang="en" class="scroll-smooth">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title></title>

  <link href='https://fonts.googleapis.com/css?family=Open Sans' rel='stylesheet'>

  <script src="https://cdn.tailwindcss.com"></script>
  <script>
    tailwind = {
      config: {
        darkMode: 'class'
      }
    };
  </script>
  <script>
    MathJax = {
        tex: {
            inlineMath: [['$', '$'], ['\\(', '\\)']],
            displayMath: [['$$', '$$'], ['\\[', '\\]']]
        }
    };
    </script>
    <script id="MathJax-script" async 
            src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js">
    </script>

  <link rel="stylesheet" href="/style.css"/>


    <style>
        /* Code block font size override - needs high specificity */
        pre[class*="language-"],
        pre[class*="language-"] code,
        code[class*="language-"] {
            font-size: 1rem !important;
            line-height: 1.4 !important;
            font-family: 'SF Mono', Consolas, 'Liberation Mono', Menlo, Courier, monospace !important;
        }

        /* Additional code styling improvements */
        pre[class*="language-"] {
            margin: 0.5em 0 !important;
            padding-left: 5px !important;
            border-radius: 0.375rem !important; /* rounded-md */
        }

        /* Dark mode toggle styling improvements */
        .dark-toggle {
          position: relative;
          display: inline-flex;
          align-items: center;
          cursor: pointer;
        }

        .dark-toggle input {
          position: absolute;
          opacity: 0;
          width: 0;
          height: 0;
        }

        .toggle-bg {
          width: 44px;
          height: 24px;
          background-color: #d1d5db;
          border-radius: 12px;
          transition: all 0.3s ease;
          position: relative;
        }

        .dark .toggle-bg {
          background-color: #374151;
        }

        .toggle-dot {
          position: absolute;
          top: 2px;
          left: 2px;
          width: 20px;
          height: 20px;
          background-color: white;
          border-radius: 50%;
          transition: transform 0.3s ease;
        }

        .dark .toggle-dot {
          background-color: #f3f4f6;
          transform: translateX(20px);
        }
    </style>

</head>

<body class="font-serif bg-white text-gray-900 dark:bg-gray-900 dark:text-gray-100 transition-colors duration-300">
  <!-- Header -->
  <!-- Header -->
<header class="border-b border-gray-200 dark:border-gray-700">
  <div class="max-w-3xl mx-auto px-4 py-6 flex justify-between items-center">
    <h1 class="text-2xl font-semibold">
        <a class="text-decoration-none" href="/" style="font-family: Open Sans">bewakes</a>
    </h1>
    
    <!-- Navigation Menu -->
    <nav class="hidden md:flex items-center space-x-6" style="font-family: Open Sans">
      <a href="/about.html" class="text-gray-600 dark:text-gray-300 hover:text-gray-900 dark:hover:text-white transition-colors">About</a>
      <a href="/now.html" class="text-gray-600 dark:text-gray-300 hover:text-gray-900 dark:hover:text-white transition-colors">Now</a>
    </nav>

    <div class="flex items-center space-x-4">
      <!-- Mobile Menu Button -->
      <button id="mobileMenuToggle" class="md:hidden p-2 text-gray-600 dark:text-gray-300 hover:text-gray-900 dark:hover:text-white">
        <svg class="w-6 h-6" fill="none" stroke="currentColor" viewBox="0 0 24 24">
          <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M4 6h16M4 12h16M4 18h16"></path>
        </svg>
      </button>
      
      <!-- Toggle Switch -->
      <label class="dark-toggle">
        <input type="checkbox" id="darkModeToggle">
        <div class="toggle-bg">
          <div class="toggle-dot"></div>
        </div>
      </label>
    </div>
  </div>

  <!-- Mobile Menu -->
  <div id="mobileMenu" class="hidden md:hidden border-t border-gray-200 dark:border-gray-700">
    <div class="max-w-3xl mx-auto px-4 py-4 space-y-2">
      <a href="/about.html" class="block py-2 text-gray-600 dark:text-gray-300 hover:text-gray-900 dark:hover:text-white transition-colors">About</a>
      <a href="/now.html" class="block py-2 text-gray-600 dark:text-gray-300 hover:text-gray-900 dark:hover:text-white transition-colors">Now</a>
    </div>
  </div>
</header>


  <main class="max-w-3xl mx-auto px-4 py-10 space-y-10">

    <div class="markdown-content">
    <header>
      <h1 class="title text-4xl text-center">Yet another Unicode demystification</h1>
      <p class="post-date text-base text-gray-600 dark:text-gray-400">Oct 14 2020</p>
    </header>
    <section class="pt-0 mt-2 mb-8">
      <div class="flex flex-wrap gap-3">
            <a href="/tags/computer-science.html" class="text-sm px-3 py-1 rounded-full bg-gray-100 text-gray-700 hover:bg-gray-200 dark:bg-gray-800 dark:text-gray-200 dark:hover:bg-gray-700 transition">
                computer-science
            </a>
      </div>
    </section>


    <article class="prose text-xl/8 dark:prose-invert lg:prose-lg max-w-none">
        <blockquote>
<p>String is an array of characters. Each character is 1 byte.</p>
</blockquote>
<p>But there's more to texts.</p>
<h3>Binary machines and ASCII</h3>
<p>Computer memories are binary: slots which can store just zeros and ones.
Numbers and binaries get along pretty well. But for charecters and alphabets,
we need some way of encoding them into binary sequences.</p>
<p>A widespread encoding for alphabetic characters is ASCII(American Standard Code
for Information Interchange). It consists all the uppercase and lowercase
English letters, numeric digits, some special characters like punctuations
and some unprintable characters. We can see what the table looks like
<a href="https://en.wikipedia.org/wiki/Ascii">here</a>.</p>
<p>ASCII table basically maps each alphabet/character to a number which can then
be stored in computer. There are 128 different ASCII characters which can be
represented by 7 bits. So, the word &quot;Tom&quot; would be represented in ASCII as:
<code>1010100 1101111 1101101</code></p>
<p>Note that, when ASCII characters are represented as bytes then the first bit is
always 0.</p>
<p>This representation was going all well in the past until computers were adopted
world wide. Different parts of world used different encodings for their
character sets.</p>
<h3>Mighty Unicode</h3>
<p>This unmoderated encodings being used all over the world produced many
incompatible systems as a result of which <a href="https://en.wikipedia.org/wiki/Unicode_Consortium">The Unicode
Consortium</a> was established
to collect and catalog all the alphabets of all spoken languages in the world.
This was the first step towards a standard system for worldwide interchange,
processing and display of texts in various languages.</p>
<p>Strictly speaking, the standard organizes characters into scripts instead of
languages because different languages can use one script. For example, Latin
script can be used by many European and American languages.</p>
<p>Now, every character in each script has a unique identifying number which we
call a code point, usually written in hexadecimal and preceeded by U+. For
example, Unicode Codepoint for the character 'A'(<code>67 = 0x43</code>) is <code>U+0043</code>.
Corresponding to each code point is a glyph, which is the graphic
representation of the symbol. For example, the unicode value for the glyph à¤• in
Devnagari script is <code>U+0915</code>.</p>
<p>The range of Unicode code space is <code>0</code> to <code>10FFFF</code> which is 21 bits. Because
computer memory is normally organized into 8-bit bytes, it would be possible to
use 3 bytes to store each code point with leading 3 bits unused. However, most
computers process information in chunks of 32 or 64 bits[as of 2020], it will
be effective to store each code point in a 32 bit(4 bytes) chunk even if the
leading 11 bits would useless and set to zero. This method of encoding is what
we've known or heard as UTF-32, UTF meaning Unicode Transfer Format.</p>
<blockquote>
<p>As an example, let's see how the letter z is stored in UTF-32. It's ASCII
value is <code>0x7A</code> which gives the code point U+007A. Now we just need to prefix
the leading zeroes to get <code>0000 0000 0000 0000 0111 1010</code></p>
</blockquote>
<p>But!!</p>
<p>While UTF-32 is effective for processing texts, it is inefficient for storing
and transmitting them. If we have a file with mostly ASCII characters, three
fourth of the file space will be occupied by zeros.</p>
<h3>UTF-8 to the rescue</h3>
<p>We must have seen utf-8 almost everywhere. This is a very popular encoding
which can represent the unicode code points with one to 3 bytes, using a single
byte for ASCII, without loosing compatibility with ASCII at all.</p>
<p>Here are the rules for UTF-8 encoding:</p>
<p>Code points from U+0000 to U+007F</p>
<p>These consist of our old ASCII friends. The first bit is 0 and the rest 7 bits
represent the characters.</p>
<p>Code points over U+007F</p>
<p>These obviously require more than 1 byte. The first byte contains information
about how many bytes will be used as well as some text data. The subsequent
bytes, called as continuation bytes will have first two bits set as 10 meaning
this is a continuation byte and last 6 bits to store codepoint data.</p>
<p>Now the first byte. If total of two bytes will be used, it will be prefixed by
110, for 3 bytes it will be prefixed by 1110 and for 4 btes it will be prefixed
by 11110. You can see the pattern here. The number of 1s in the prefix denote
the number of bytes. The 1s are immediately followed by a 0 after which the
remaining bits of the first byte are used for data. The remaining bits are
distributed to subsequent continuation bytes.</p>
<p>The following table clarifies the concept. Note that the xs denote data bits
for the codepoint. Source at the bottom</p>
<h3>An Example doesn't hurt</h3>
<p>Now let's try it out with a code point U+1F923 whose corresponding emoticon is
'ðŸ¤£' [Laughing at programmer's misery].</p>
<ul>
<li>First, note that it lies between U+10000 and U+1FFFFF.</li>
<li>So, we need 4 bytes to represent this code point.</li>
<li>The 21 bits are: 0 0001 1111 1001 0010 0011 each corresponding to 1, F, 9, 2 and 3.</li>
<li>The first byte becomes 11110 000. Note the four leading 1's followed by a zero. The last 3 zeros are first 3
bits from above 21 bits.</li>
<li>Let's construct second byte which is a continuation by prefixing with 10. We get: 10 01 1111.</li>
<li>Similarly, the third byte becomes: 10 1001 00.</li>
<li>And the last byte: 10 10 0011.</li>
<li>Combining all of them, the UTF-8 bits are: 11110000 10011111 10100100 10100011 which, in hex, is: 0xF09F A4A3.</li>
</ul>
<p>Pheww!! That was something. I hope Unicodes are now friendlier than before.</p>
<p><em>Summarized from Computer Systems, J. Stanley Warford: Chapter 3</em></p>

    </article>
</div>


  </main>

  <!-- Footer -->
  <footer class="border-t border-gray-200 dark:border-gray-700 mt-16 py-6 text-center text-sm text-gray-500 dark:text-gray-400">
    &copy; 2025 bewakes.
  </footer>

  <script>
    const toggle = document.getElementById('darkModeToggle');
    const htmlEl = document.documentElement;

    // Function to load Prism theme
    function loadPrismTheme(isDark) {
      // Remove existing theme
      const existingTheme = document.querySelector('link[data-prism-theme]');
      if (existingTheme) {
        existingTheme.remove();
      }

      // Add new theme
      const themeLink = document.createElement('link');
      themeLink.rel = 'stylesheet';
      themeLink.setAttribute('data-prism-theme', 'true');
      
      if (isDark) {
        themeLink.href = 'https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism-tomorrow.min.css';
      } else {
        themeLink.href = 'https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css';
      }
      
      document.head.appendChild(themeLink);
      
      // Re-highlight after theme loads and Prism is ready
      themeLink.onload = function() {
        setTimeout(() => {
          if (typeof Prism !== 'undefined') {
            Prism.highlightAll();
          }
        }, 50);
      };
    }

    // Check for saved theme preference or default to light mode
    const savedTheme = localStorage.getItem('theme');
    const prefersDark = window.matchMedia('(prefers-color-scheme: dark)').matches;
    
    // Initialize theme
    if (savedTheme === 'dark' || (!savedTheme && prefersDark)) {
      htmlEl.classList.add('dark');
      toggle.checked = true;
      loadPrismTheme(true);
    } else {
      htmlEl.classList.remove('dark');
      toggle.checked = false;
      loadPrismTheme(false);
    }

    // Toggle event listener
    toggle.addEventListener('change', () => {
      if (toggle.checked) {
        htmlEl.classList.add('dark');
        localStorage.setItem('theme', 'dark');
        loadPrismTheme(true);
      } else {
        htmlEl.classList.remove('dark');
        localStorage.setItem('theme', 'light');
        loadPrismTheme(false);
      }
    });
  </script>

  <!-- Prism.js JavaScript -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-core.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/plugins/autoloader/prism-autoloader.min.js"></script>

    <script>
        // Configure autoloader path
        Prism.plugins.autoloader.languages_path = 'https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/';

    </script>
  <!-- END Prism.js JavaScript -->
    <script>
        // Mobile menu toggle functionality
        document.getElementById('mobileMenuToggle').addEventListener('click', function() {
          const mobileMenu = document.getElementById('mobileMenu');
          mobileMenu.classList.toggle('hidden');
        });

        // Close mobile menu when clicking outside
        document.addEventListener('click', function(event) {
          const mobileMenu = document.getElementById('mobileMenu');
          const mobileMenuToggle = document.getElementById('mobileMenuToggle');
          
          if (!mobileMenuToggle.contains(event.target) && !mobileMenu.contains(event.target)) {
            mobileMenu.classList.add('hidden');
          }
        });
    </script>

</body>
</html>
